# Практическая работа по работе с ссылками и systemd

## Обзор заданий

В данной практической работе необходимо выполнить четыре задания:
1. Доработать скрипт delete.sh для работы с жёсткими и символическими ссылками
2. Создать systemd-юнит для очистки корзины
3. Написать скрипт для превращения символических ссылок в обычные файлы
4. Ответить на вопросы о работе с символическими ссылками

---

## Задание 1: Доработка скрипта delete.sh

### Цель задания
Проверить качество своего понимания концепции жёстких ссылок. Закрепить навыки, полученные на уроке.

### Что нужно сделать
Доработайте скрипт delete.sh с учётом того, что файл, который пользователь пытается удалить, может быть символической или жёсткой ссылкой.

**Требования:**
- Если это символическая ссылка, необходимо удалять её без архивирования и возвращать пользователю:
  - сообщение о том, что удалена только ссылка
  - имя оригинального файла, на который ссылается символическая ссылка
- Добавьте проверку, чтобы определить, является ли файл жёсткой ссылкой. Если да — удаляйте файл обычным способом и выводите пользователю список ссылок на этот файл

### Выполнение в Docker контейнере

#### Шаг 0: Подготовка Docker контейнера
```bash
# Запускаем Ubuntu контейнер
docker run --rm -it ubuntu /bin/bash

# Обновляем пакеты
apt update

# Устанавливаем необходимые утилиты
apt install -y coreutils findutils
```

#### Шаг 1: Создание базового скрипта delete.sh
```bash
# Создаем директорию для скриптов
mkdir -p ~/scripts
cd ~/scripts

# Создаем базовый скрипт delete.sh
cat > delete.sh << 'EOF'
#!/bin/bash

# Проверяем количество аргументов
if [ $# -ne 1 ]; then
    echo "Использование: $0 <файл>"
    exit 1
fi

FILE="$1"

# Проверяем существование файла
if [ ! -e "$FILE" ]; then
    echo "Ошибка: файл '$FILE' не существует"
    exit 1
fi

# Создаем директорию TRASH если её нет
mkdir -p ~/TRASH

# Получаем базовое имя файла
BASENAME=$(basename "$FILE")

# Проверяем тип файла
if [ -L "$FILE" ]; then
    # Символическая ссылка
    echo "Обнаружена символическая ссылка: $FILE"
    
    # Получаем цель ссылки
    TARGET=$(readlink "$FILE")
    echo "Цель ссылки: $TARGET"
    
    # Удаляем символическую ссылку
    rm "$FILE"
    echo "Символическая ссылка '$FILE' удалена"
    echo "Оригинальный файл '$TARGET' остался нетронутым"
    
elif [ $(stat -c %h "$FILE") -gt 1 ]; then
    # Жёсткая ссылка (количество ссылок больше 1)
    echo "Обнаружена жёсткая ссылка: $FILE"
    
    # Находим все жёсткие ссылки на этот файл
    INODE=$(stat -c %i "$FILE")
    echo "Найдены жёсткие ссылки на файл:"
    find $(dirname "$FILE") -samefile "$FILE" 2>/dev/null
    
    # Перемещаем файл в корзину
    mv "$FILE" ~/TRASH/"$BASENAME.$(date +%s)"
    echo "Файл '$FILE' перемещён в корзину ~/TRASH"
    
else
    # Обычный файл
    echo "Обычный файл: $FILE"
    
    # Перемещаем файл в корзину
    mv "$FILE" ~/TRASH/"$BASENAME.$(date +%s)"
    echo "Файл '$FILE' перемещён в корзину ~/TRASH"
fi
EOF

# Делаем скрипт исполняемым
chmod +x delete.sh
```

#### Шаг 2: Тестирование скрипта
```bash
# Создаем тестовые файлы и ссылки
mkdir -p ~/test_files
cd ~/test_files

# Создаем обычный файл
echo "Содержимое обычного файла" > ordinary_file.txt

# Создаем жёсткую ссылку
ln ordinary_file.txt hard_link.txt

# Создаем символическую ссылку
ln -s ordinary_file.txt symlink.txt

# Проверяем созданные файлы
ls -la

# Тестируем скрипт с обычным файлом
~/scripts/delete.sh ordinary_file.txt

# Тестируем скрипт с жёсткой ссылкой
~/scripts/delete.sh hard_link.txt

# Тестируем скрипт с символической ссылкой
~/scripts/delete.sh symlink.txt

# Проверяем содержимое корзины
ls -la ~/TRASH/
```

### Что оценивается
Навыки написания bash-скриптов. Понимание работы с символическими и жёсткими ссылками.

### Как отправить задание на проверку
Пришлите содержимое скрипта в виде скриншота. Пришлите скриншоты результата работы в случаях, если переданный скрипту файл — жёсткая или символическая ссылка.

---

## Задание 2: Создание systemd-юнита

### Цель задания
Освоить на практике написание простых systemd-юнитов.

### Что нужно сделать
Напишите systemd-юнит, который будет запускать очистку файлов в директории ~/TRASH (которые попадают туда после работы скрипта delete для безопасного удаления файлов, реализованного в прошлых модулях) раз в час, удаляя файлы старше дня.

### Выполнение в Docker контейнере

#### Шаг 1: Создание скрипта очистки
```bash
# Создаем скрипт очистки корзины
cat > ~/scripts/cleanup_trash.sh << 'EOF'
#!/bin/bash

TRASH_DIR="$HOME/TRASH"
LOG_FILE="$HOME/cleanup_trash.log"

# Проверяем существование директории корзины
if [ ! -d "$TRASH_DIR" ]; then
    echo "$(date): Директория корзины $TRASH_DIR не существует" >> "$LOG_FILE"
    exit 1
fi

# Удаляем файлы старше 1 дня
DELETED_COUNT=$(find "$TRASH_DIR" -type f -mtime +1 -delete -print | wc -l)

echo "$(date): Удалено $DELETED_COUNT файлов из корзины" >> "$LOG_FILE"
EOF

# Делаем скрипт исполняемым
chmod +x ~/scripts/cleanup_trash.sh
```

#### Шаг 2: Создание systemd-юнита
```bash
# Создаем systemd-юнит для очистки корзины
cat > /etc/systemd/system/cleanup-trash.service << 'EOF'
[Unit]
Description=Cleanup TRASH directory
After=network.target

[Service]
Type=oneshot
User=root
ExecStart=/root/scripts/cleanup_trash.sh
StandardOutput=journal
StandardError=journal
EOF

# Создаем timer для запуска каждые 60 минут
cat > /etc/systemd/system/cleanup-trash.timer << 'EOF'
[Unit]
Description=Run cleanup-trash every hour
Requires=cleanup-trash.service

[Timer]
OnCalendar=hourly
Persistent=true

[Install]
WantedBy=timers.target
EOF

# Перезагружаем systemd
systemctl daemon-reload

# Включаем и запускаем timer
systemctl enable cleanup-trash.timer
systemctl start cleanup-trash.timer

# Проверяем статус
systemctl status cleanup-trash.timer
systemctl list-timers cleanup-trash.timer
```

#### Шаг 3: Тестирование
```bash
# Создаем тестовые файлы в корзине
mkdir -p ~/TRASH
touch ~/TRASH/old_file.txt
touch ~/TRASH/new_file.txt

# Устанавливаем старую дату для одного файла
touch -t 202301010000 ~/TRASH/old_file.txt

# Запускаем очистку вручную
systemctl start cleanup-trash.service

# Проверяем результат
ls -la ~/TRASH/
cat ~/cleanup_trash.log
```

### Альтернативный вариант с cron (если systemd недоступен)
```bash
# Создаем cron-задачу для очистки каждый час
echo "0 * * * * /root/scripts/cleanup_trash.sh" | crontab -

# Проверяем cron-задачи
crontab -l
```

### Что оценивается
Навыки создания простых юнитов. Навыки работы с systemd.

### Как отправить задание на проверку
Пришлите содержимое юнит-файлов в виде скриншота. Пришлите скриншот запуска сервиса.

---

## Задание 3: Превращение символических ссылок в файлы

### Цель задания
Закрепить навыки работы с символическими ссылками.

### Что нужно сделать
Напишите скрипт, который будет «превращать» символические ссылки в обычный файл с содержимым, находящимся по символической ссылке.

### Выполнение в Docker контейнере

#### Шаг 1: Создание скрипта
```bash
# Создаем скрипт для превращения симлинков в файлы
cat > ~/scripts/symlink_to_file.sh << 'EOF'
#!/bin/bash

# Проверяем количество аргументов
if [ $# -ne 1 ]; then
    echo "Использование: $0 <символическая_ссылка>"
    exit 1
fi

SYMLINK="$1"

# Проверяем, что это символическая ссылка
if [ ! -L "$SYMLINK" ]; then
    echo "Ошибка: '$SYMLINK' не является символической ссылкой"
    exit 1
fi

# Получаем цель ссылки
TARGET=$(readlink "$SYMLINK")

# Проверяем, что цель существует
if [ ! -e "$TARGET" ]; then
    echo "Ошибка: цель ссылки '$TARGET' не существует"
    exit 1
fi

# Создаем временный файл
TEMP_FILE=$(mktemp)

# Копируем содержимое цели в временный файл
if cp "$TARGET" "$TEMP_FILE"; then
    # Удаляем символическую ссылку
    rm "$SYMLINK"
    
    # Перемещаем временный файл на место ссылки
    mv "$TEMP_FILE" "$SYMLINK"
    
    echo "Символическая ссылка '$SYMLINK' успешно превращена в обычный файл"
    echo "Содержимое скопировано из '$TARGET'"
else
    echo "Ошибка: не удалось скопировать содержимое из '$TARGET'"
    rm -f "$TEMP_FILE"
    exit 1
fi
EOF

# Делаем скрипт исполняемым
chmod +x ~/scripts/symlink_to_file.sh
```

#### Шаг 2: Тестирование скрипта
```bash
# Создаем тестовые файлы
mkdir -p ~/test_symlinks
cd ~/test_symlinks

# Создаем файл с содержимым
echo "Это содержимое оригинального файла" > original.txt

# Создаем символическую ссылку
ln -s original.txt symlink.txt

# Проверяем созданные файлы
ls -la
file symlink.txt

# Превращаем символическую ссылку в файл
~/scripts/symlink_to_file.sh symlink.txt

# Проверяем результат
ls -la
file symlink.txt
cat symlink.txt

# Проверяем, что оригинальный файл остался
cat original.txt
```

#### Шаг 3: Тестирование с директориями
```bash
# Создаем директорию и файл в ней
mkdir test_dir
echo "Файл в директории" > test_dir/file.txt

# Создаем символическую ссылку на директорию
ln -s test_dir symlink_dir

# Превращаем симлинк на директорию в файл
~/scripts/symlink_to_file.sh symlink_dir

# Проверяем результат
ls -la symlink_dir
file symlink_dir
```

### Что оценивается
Навыки написания bash-скриптов.

### Как отправить задание на проверку
Пришлите содержимое скрипта в виде скриншота. Пришлите скриншот результатов работы скрипта.

---

## Задание 4: Вопросы о символических ссылках

### Цель задания
Закрепить навыки работы с символическими ссылками.

### Что нужно сделать
Ответьте на вопросы:

1. **Что произойдёт, если скопировать символическую ссылку из одной папки в другую запуском команды вида `cp symlink /path/to/new/dir`?**

2. **Как скопировать символическую ссылку правильно?**

### Практическое исследование в Docker

#### Шаг 1: Подготовка тестовой среды
```bash
# Создаем тестовые директории
mkdir -p ~/test_cp/{source,target}
cd ~/test_cp

# Создаем файл и символическую ссылку
echo "Содержимое оригинального файла" > source/original.txt
ln -s original.txt source/symlink.txt

# Проверяем созданные файлы
ls -la source/
```

#### Шаг 2: Тестирование обычного копирования
```bash
# Копируем символическую ссылку обычной командой cp
cp source/symlink.txt target/

# Проверяем результат
ls -la target/
file target/symlink.txt
cat target/symlink.txt
```

#### Шаг 3: Тестирование правильного копирования
```bash
# Очищаем целевую директорию
rm -rf target/*
mkdir target

# Копируем символическую ссылку с опцией -P (сохранять символические ссылки)
cp -P source/symlink.txt target/

# Проверяем результат
ls -la target/
file target/symlink.txt
cat target/symlink.txt
```

#### Шаг 4: Тестирование с опцией -d
```bash
# Очищаем целевую директорию
rm -rf target/*
mkdir target

# Копируем символическую ссылку с опцией -d (сохранять ссылки)
cp -d source/symlink.txt target/

# Проверяем результат
ls -la target/
file target/symlink.txt
cat target/symlink.txt
```

### Ответы на вопросы

#### Вопрос 1: Что произойдёт при обычном копировании?
**Ответ:** При использовании команды `cp symlink /path/to/new/dir` по умолчанию копируется **содержимое файла**, на который указывает символическая ссылка, а не сама ссылка. В результате в целевой директории создастся обычный файл с содержимым оригинального файла.

#### Вопрос 2: Как скопировать символическую ссылку правильно?
**Ответ:** Для правильного копирования символической ссылки используйте одну из опций:
- `cp -P symlink /path/to/new/dir` - сохраняет символические ссылки
- `cp -d symlink /path/to/new/dir` - сохраняет ссылки (символические и жёсткие)

### Что оценивается
Понимание концепции символических ссылок.

### Как отправить задание на проверку
Напишите ответ в форме для сдачи домашнего задания.

---

## Полезные команды для всех заданий

### Для работы со ссылками
```bash
# Создание символических ссылок
ln -s target symlink

# Создание жёстких ссылок
ln target hardlink

# Проверка типа ссылки
ls -la file
file file
stat file

# Поиск всех жёстких ссылок на файл
find . -samefile file

# Получение цели символической ссылки
readlink symlink
```

### Для работы с systemd
```bash
# Управление сервисами
systemctl start service
systemctl stop service
systemctl restart service
systemctl status service

# Управление таймерами
systemctl start timer.timer
systemctl stop timer.timer
systemctl list-timers

# Перезагрузка конфигурации
systemctl daemon-reload
```

### Для работы с файлами
```bash
# Проверка типа файла
file filename
ls -la filename

# Создание временных файлов
mktemp
mktemp -d

# Проверка времени модификации
find . -mtime +1  # файлы старше 1 дня
find . -mtime -1  # файлы младше 1 дня
```

## Порядок выполнения

1. **Задание 1**: Создайте и протестируйте доработанный скрипт delete.sh
2. **Задание 2**: Создайте systemd-юнит для очистки корзины
3. **Задание 3**: Создайте скрипт для превращения симлинков в файлы
4. **Задание 4**: Исследуйте поведение cp с символическими ссылками

## Требования к скриншотам

- **Задание 1**: 
  - Содержимое скрипта delete.sh
  - Результат работы с жёсткой ссылкой
  - Результат работы с символической ссылкой
- **Задание 2**: 
  - Содержимое файлов .service и .timer
  - Статус запущенного сервиса
- **Задание 3**: 
  - Содержимое скрипта symlink_to_file.sh
  - Результат работы скрипта
- **Задание 4**: 
  - Результаты тестирования команд cp
